package com.aliyun.odps.web3.common;

import org.web3j.abi.FunctionReturnDecoder;
import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.AbiTypes;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * @Author: smy
 * @Date: 2023/3/13 3:26 PM
 */
public class ContractUtils {


    /**
     * decode nonIndex data
     *
     * Example:
     *      decodeParameter(log.data, "bytes32,bytes32,uint")
     * @param data
     * @param nonIndexParameters
     * @return
     */
    public static List<Type> decodeParameter(String data, String nonIndexParameters) {
        String[] types = nonIndexParameters.split(",");
        List<TypeReference<Type>> parameters = new ArrayList<>();
        for (String type : types) {
            try {
                parameters.add(TypeReference.makeTypeReference(type));
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
        return FunctionReturnDecoder.decode(data, parameters);
    }

    /**
     * decode index data
     *
     * Example:
     *      decodeIndexedValue(log.topic2, "bytes32")
     * @param data
     * @param type
     * @return
     */
    public static Type decodeIndexedValue(String data, String type) {
        return FunctionReturnDecoder.decodeIndexedValue(data, TypeReference.create(AbiTypes.getType(type)));
    }

    /**
     * decode transaction's input data
     *
     * Example:
     *      decodeInputData(transaction.input, "atomicMatch_","address[14],uint256[18],uint8[8],bytes,bytes,bytes,bytes,bytes,bytes,uint8[2],bytes32[5]")
     * @param inputData
     * @param methodName
     * @param noIndexParameters
     * @return
     * @throws ClassNotFoundException
     */
    public static List<Type> decodeInputData(String inputData,
                                             String methodName,
                                             String noIndexParameters) {

        List<TypeReference<?>> parameters = new ArrayList<>();
        for (String type : noIndexParameters.split(",")) {
            try {
                parameters.add(TypeReference.makeTypeReference(type));
            } catch (ClassNotFoundException e) {
                throw new RuntimeException(e);
            }
        }
        Function function = new Function(methodName, Collections.emptyList(), parameters);
        List<Type> result = FunctionReturnDecoder.decode(
                inputData.substring(10),
                function.getOutputParameters());
        return result;
    }

    public static void main(String[] args) throws ClassNotFoundException {
        String inputData = "0xab834bab0000000000000000000000007be8076f4ea4a4ad08075c2508e481d6c946d12b000000000000000000000000cef0633dc36e6b539ff42b21ab9ab1a3ca9acfe3000000000000000000000000173309061808168ab41179bf117d3dfd59c527e80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000db3b2e1f699caf230ee75bfbe7d97d70f81bc945000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007be8076f4ea4a4ad08075c2508e481d6c946d12b000000000000000000000000173309061808168ab41179bf117d3dfd59c527e800000000000000000000000000000000000000000000000000000000000000000000000000000000000000005b3256965e7c3cf26e11fcaf296dfc8807c01073000000000000000000000000db3b2e1f699caf230ee75bfbe7d97d70f81bc9450000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002ee0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000186cc6acd4b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000061a9d67e000000000000000000000000000000000000000000000000000000000000000022269f0ddf91d26ef9af91046521e7a33b280450e6adaf47d445ad971c93624900000000000000000000000000000000000000000000000000000000000002ee0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000186cc6acd4b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000061a9818000000000000000000000000000000000000000000000000000000000629964ce8e89508b03903c1fcc88e267879785b8fe5a749bc8afe71fd22590ecaaba7fcd0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006a0000000000000000000000000000000000000000000000000000000000000074000000000000000000000000000000000000000000000000000000000000007e0000000000000000000000000000000000000000000000000000000000000088000000000000000000000000000000000000000000000000000000000000009200000000000000000000000000000000000000000000000000000000000000940000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000001c6aaa783a6cda194bf0a787d7e103904a6d05f06cc6be57d79886382f1a23e53b69ad6242492517ff3f78aa897ab3e4586aa63b978bd5532012223893e6a3a1b26aaa783a6cda194bf0a787d7e103904a6d05f06cc6be57d79886382f1a23e53b69ad6242492517ff3f78aa897ab3e4586aa63b978bd5532012223893e6a3a1b20000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006423b872dd0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000cef0633dc36e6b539ff42b21ab9ab1a3ca9acfe3000000000000000000000000000000000000000000000000000000000000115d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006423b872dd000000000000000000000000173309061808168ab41179bf117d3dfd59c527e80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000115d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        List<Type> result = decodeInputData(inputData, "atomicMatch_",
                "address[14],uint256[18],uint8[8],bytes,bytes,bytes,bytes,bytes,bytes,uint8[2],bytes32[5]");
        TypeConvertUtils.convert2String(result).forEach(d -> System.out.println(d));
    }
}
